// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: txn.sql

package sqlc

import (
	"context"
	"time"
)

const createTxn = `-- name: CreateTxn :one
INSERT INTO txn(timestamp, amount, category, description)
    VALUES (?, ?, ?, ?)
RETURNING
    id, timestamp, amount, category, description
`

type CreateTxnParams struct {
	Timestamp   time.Time
	Amount      int64
	Category    string
	Description *string
}

func (q *Queries) CreateTxn(ctx context.Context, arg CreateTxnParams) (Txn, error) {
	row := q.db.QueryRowContext(ctx, createTxn,
		arg.Timestamp,
		arg.Amount,
		arg.Category,
		arg.Description,
	)
	var i Txn
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.Amount,
		&i.Category,
		&i.Description,
	)
	return i, err
}

const deleteTxn = `-- name: DeleteTxn :one
DELETE FROM txn
WHERE id = ?
RETURNING
    id, timestamp, amount, category, description
`

func (q *Queries) DeleteTxn(ctx context.Context, id int64) (Txn, error) {
	row := q.db.QueryRowContext(ctx, deleteTxn, id)
	var i Txn
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.Amount,
		&i.Category,
		&i.Description,
	)
	return i, err
}

const getTxn = `-- name: GetTxn :one
SELECT
    id, timestamp, amount, category, description
FROM
    txn
WHERE
    id = ?
`

func (q *Queries) GetTxn(ctx context.Context, id int64) (Txn, error) {
	row := q.db.QueryRowContext(ctx, getTxn, id)
	var i Txn
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.Amount,
		&i.Category,
		&i.Description,
	)
	return i, err
}

const listTxns = `-- name: ListTxns :many
SELECT
    id, timestamp, amount, category, description
FROM
    txn
WHERE (timestamp > ?3
    OR ?3 IS NULL)
AND (timestamp < ?4
    OR ?4 IS NULL)
AND (category = ?5
    OR ?5 IS NULL)
ORDER BY
    timestamp DESC
LIMIT ? OFFSET ?
`

type ListTxnsParams struct {
	StartTime *time.Time
	EndTime   *time.Time
	Category  *string
	Limit     int64
	Offset    int64
}

func (q *Queries) ListTxns(ctx context.Context, arg ListTxnsParams) ([]Txn, error) {
	rows, err := q.db.QueryContext(ctx, listTxns,
		arg.StartTime,
		arg.EndTime,
		arg.Category,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Txn
	for rows.Next() {
		var i Txn
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.Amount,
			&i.Category,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTxn = `-- name: UpdateTxn :one
UPDATE
    txn
SET
    timestamp = ?,
    amount = ?,
    category = ?,
    description = ?
WHERE
    id = ?
RETURNING
    id, timestamp, amount, category, description
`

type UpdateTxnParams struct {
	Timestamp   time.Time
	Amount      int64
	Category    string
	Description *string
	ID          int64
}

func (q *Queries) UpdateTxn(ctx context.Context, arg UpdateTxnParams) (Txn, error) {
	row := q.db.QueryRowContext(ctx, updateTxn,
		arg.Timestamp,
		arg.Amount,
		arg.Category,
		arg.Description,
		arg.ID,
	)
	var i Txn
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.Amount,
		&i.Category,
		&i.Description,
	)
	return i, err
}
